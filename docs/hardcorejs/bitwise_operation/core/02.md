# 按位非 NOT（~）

## 简述

按位非操作符也可以叫按位取反，它使用 `~` 符号表示，作用是对位取反，1 变成 0 ，0 变成 1

看过上文的小伙伴们可能就会发现，这好像是取的反码？

是的，我们就可以直接理解为按位非就是取其二进制的反码，只不过，反码是符号位不变其余位置取反，而按位非则是取反码后符号位也取反



**例如：**

我们以 8 位（bit）数字存储为例

求十进制数字 2 的按位非，十进制数字 2 的二进制是 `0000 0010`，那么它的二进制反码就是 `0111 1101`，符号位也取反则变成了 `1111 1101`，当然你也可以直接将数字 2 的二进制每一位取反，结果都是 `1111 1101` 

我们知道符号位为 1 代表是负数，而计算机中存储负数是以补码的方式来存储的，所以我们对补码 `1111 1101` 求原码再转成十进制即可，对补码求原码就是使用此补码再求一遍补码，也就是先取反码再补 1 ，过程自算，得到了负数的二进制原码 `1000 00 11`，即十进制 `-3`  

同上所述

十进制数字 1 的按位非即十进制 `-2` 

十进制数字 0 的按位非即十进制 `-1`  

上面说的都是正数，我们看一个负数的例子

十进制数字 -1 由于是负数，上文我们说过计算机中二进制存储负数为补码方式，所以我们要先求 -1 的补码，-1 二进制原码是 `1000 0001`，再求原码的反码即 `1111 1110` ，接着补 1 即可求补码即 `1111 1111`，那么我们得到了 -1 在二进制中存储的的最终补码形态即为 `1111 1111` ，最终我们将此二进制每一位都取反得到 `0000 0000 `，即十进制数字 0



诶！好像有规律，我们试了几次之后发现按位非的最终结果始终是对原数值取反并减一，如下

```js
let a = 1
console.log(~a == (-a) - 1) // true

// 得到
~x = (-x) - 1
```

知道这个之后，我们遇到按位非操作符后可以根据这个规律来算结果，会比转二进制计算那样方便些

那么又有人说了，既然和 `(-x) - 1` 是一致的，那么为什么还要用按位非呢

很简单，原因有二，第一是位运算的操作是在数值底层表示上完成的，速度快。第二是因为它只用 2 个字符，比较方便。。。



## 使用按位非 ~ 判断是否等于-1

按位非在项目中的使用频率还是蛮高的

相信大家经常看到下面这种写法

```js
let str = "abcdefg"

if(!~str.indexOf("n")){
	console.log("字符串 str 中不存在字符 n")
}

// 等同于

if(str.indexOf("n") == "-1"){
  console.log("字符串 str 中不存在字符 n")
}
```

如上所示，我们知道 `indexOf` 方法在找不到相同值时返回 -1，而 `~-1 == 0 == false` ，所以 `!~-1 == 1 == true` ，一般来说我们使用按位非的写法来校验 -1 是用的最多，也是位运算中最容易令大家接受的了，是不是特别简单方便呢



## 使用按位非 ~ 取整

按位非的骚操作中，还有一个比较普遍的就是位运算双非取整了，如下所示

```js
~~3.14 == 3
```

很多人知道这样可以取整，但是由于不知道具体是为什么而不敢用，所以我们来解释下为什么它为什么可以取整

上面我们说过，在 JS 位运算中，并不会用 64 位来计算，它会先在后台把值转换为 32 位整数，再进行位运算操作，位运算计算完成后再将 32 位转为 64 位存储，整个过程就像在处理 32 位数值一样，所以我们了解位运算时，只需要关注这 32 位二进制整数就可以

这里我们可以看到，32 位 `整数`，位运算操作的是整数，后台在进行 64 位到 32 位转换时，会忽略掉小数部分，只关注整数、整数、整数，记住了

```js
~3.14 == ~3
-5.89 == ~5
```

如上所示，接着我们再按照上面的公式

```js
~x == (-x) - 1

~~x == -((-x) - 1) -1 == -(-x) + 1 -1 == x
```

所以位运算中的双非 `~~` 即可取整，此取整是完全忽略小数部分
