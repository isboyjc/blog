# 原码、反码和补码

再说 JS 中的数字问题前，我们还需要补充了解下原码、反码和补码的概念，这里暂先不说结论，我们一步一步的来看，最后在总结什么是原码、反码和补码



## 起源

计算机里保存的是最原始的数字，也就是没有正和负的数字，我们称之为无符号数字

假如我们在内存中用 4 位（也就是4bit）去存放表示无符号数字，是下面这样子的

**PS：** 这里也说了是假如，当然你也可以用 32 位来理解，这里只是为了解释原码、反码、补码的概念，多少位只有一个区别，那就是可存储的值范围大小不同，可存储位数越大，可以存储的值范围就越大，这点后面会说到，这都不重要，主要是 32 位画图太累。。。

![](http://qiniuimages.isboyjc.com/PictureBed/other/image-20201122183341034.png)

我们可能注意到了，这样好像没办法表达负数

So，为了表示正与负，先辈们就发明了 **原码**，把左边第一位腾出来，存放符号，正数用 0 来表示，负用 1 来表示

![](http://qiniuimages.isboyjc.com/PictureBed/other/image-20201117212137235.png)

上图就是正负数的 `原码`，你可能在疑惑为什么上面表里我只画到了数字 7，上面也说了，我们这里使用的示例是 4 位（bit）的存储方式，只存 4 位，还有一位是符号位，十进制 7 的二进制表达方式就是 0111 了，数字 8 二进制算上符号为是 01000，这就 5 位了，就不是 4 位二进制能存下的了，所以，在只有 4 位存储二进制时，原码的取值范围只有 `-7 ～ +7` 

`原码` 这种方式对人来说是很好理解的，但是机器不了解啊，表达值没问题，但是正负相加怎么加呢？

假如我们要用 `(+1) + (-1)` ，这个我们上过小学就知道等于 0，但是按照计算机的二进制计算方式，`0001 + 1001 = 1010` ，我们对比下原码表，也就是 -2

很明显，这样计算是不对的，还有就是我们会看到，原码中的 0 有两种表示：+0 和 -0，这明显也是不对的

为了解决正负相加等于 0 的问题，先辈们又在 `原码` 的基础上发明了 `反码`

正数的反码还是等同于原码，`反码` 的表示方式其实就是用来处理负数的，也就是除符号位不变，其余位置皆取反存储，0 就存 1，1 就存 0

那么我们再来看

![](http://qiniuimages.isboyjc.com/PictureBed/other/image-20201122183505866.png)

同上，4 位反码的值存储范围也是 `-7 ～ +7`

当 `原码` 变成了 `反码` ，我们看之前的（+1）和（-1）相加，变成了 `0001 + 1110 = 1111`，相加结果对比反码表， 1111 也就是 -0 ，就完美的解决了正负相加等于 0 的问题

但是，如果使用 `反码` 存储数值，还是存在那个问题，即 （+0）和（-0）这两个相同的值，存在两个不同的二进制表达方式

于是先辈们为了解决这个问题，又提出了 `补码` 的概念，也是针对 `负数` 来做处理的，即从原来 `反码` 的基础上，补充一个新的代码 1

![](http://qiniuimages.isboyjc.com/PictureBed/other/image-20201122183627781.png)

如上图所示，处理 `反码` 中的 -0 时，给 1111 再补上一个 1 之后，就变成了 10000，由于我们是 4 位存储，所以要丢掉除符号位的最左侧高位，也就是进位中的那一位，也就变成了 0000，刚好和左边正数的 0 相等

完美解决了（+0）和（-0）同时存在的问题

我们看补码表中由于 -0 的补码是 `0000` 等同于 +0，因为它补了 1嘛，我们发现 -0 就没有了意义，所以去掉了 -0 这个数字

我们再看负 7 的补码也就是反码加了 1 后的二进制表达方式为 `1001` ，以 4 位存储的方式我们发现补码表 `1001` 还可以再小一位，也就是 `1000` 即 -8，如下图

![](http://qiniuimages.isboyjc.com/PictureBed/other/image-20201117225925521.png)

于是补码的最后补上了一个 -8，也就是在 4 位存储中补码的值表达范围是 `-8 ～ +7` 

同时，我们在使用 `补码` 时，正负相加等于 0 的问题也同样可以解决

**例：**

我们把（+4）和（-4）相加，0100 + 1100 =10000，有进位，把最高位丢掉，也就是 0000（0）

接下来我们就可以梳理总结下什么是原码、反码、补码了



## 原码

原码其实就是数值前面增加了一位符号位（即最高位为符号位），正数时符号位为 0

负数时符号位为 1（0有两种表示：+0 和 -0），其余位表示数值的大小

**例：**

我们这次使用 8 位（bit）二进制表示一个数，那么正 5 的原码为 `0000 0101`，负 5 的原码就是 `1000 0101`，区别只有符号位



## 反码

正数的反码与其原码相同

负数的反码是对其原码除符号位外，皆取反

**例：**

使用 12 位（bit）二进制来表示一个数值，那么正 5 的反码等同于原码即为 `0000 0000 0101`，负 5 的反码符号位为 1 ，其余取反即为 `1111 1111 1010` 



## 补码

正数的补码与其原码相同

负数的补码是在其反码的末位加 1去掉最高进位

**例：**

使用 32 位（bit）二进制来表示，那么正 5 的补码等同于原码即为 `0000 0000 0000 0000 0000 0000 0000 0101`，负 5 的补码在反码末位补 1 去掉最高进位，由于负 5 的反码加 1 无进位，即为 `1111 1111 1111 1111 1111 1111 1111 1011` 



## 根据补码求原码

上文我们知晓了原码、反码、补码的概念后，应该已经了解了由原码转换为反码的过程，但是，若已知一个数的补码，求原码的操作呢？

其实，已知补码求原码的操作就是对这个补码再求补码

如果补码的符号位为 0，表示是一个正数，那么它的原码就是它的补码

如果补码的符号位为 1，表示是一个负数，那就直接对这个补码再求一遍它的的补码就是它的原码

**例：** 

求补码 `1001` 即十进制 -7 的原码

我们对补码再求补码，也就是先取反再补 1 ，取反得 `1110` ，再补一得 `1111`，我们对照上文中 -7 的原码，正是 `1111` 



## 二进制在内存中以补码存储

如上述，此时再和大伙说最终结论，二进制数在内存中最终是以补码的形式存储的，现在知道为什么用补码存储了吗，你 GET 到了吗？

使用补码，我们可以很方便的将减法运算转化成加法运算，运算过程得到简化，正数的补码即是它所表示的数的真值，而负数的补码的数值部份却不是它所表示的数的真值，采用补码进行运算，所得结果仍为补码

与原码、反码不同，数值 0 的补码只有一个，4 位为例，即为 0000 

再次补充，32 位、12位、8 位和 4 位等的不同就是存储的值范围，就像 8 位存储原码和反码的有效值范围是 `-127 ～ +127`，补码范围是 `-128 ~ +127`，而 4 位原码和反码范围是 `-7 ～ +7`，补码范围是 `-8 ～ +7`，这下你大概了解到为什么 JS 会有最大和最小有效数字这个概念了吧

当然我们现在只考虑了整数，并没有说小数，是为了方便我们理解原码、反码和补码，接着来道
