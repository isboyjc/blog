# JavaScript中数字存储

`JavaScript` 不是类型语言，它与许多其他编程语言不同，`JavaScript` 没有不同类型的数字，比如整数、短、长、浮点等等

在 `JavaScript` 中，数字不分为整数和浮点型，也就是所有的数字都是使用浮点型类型来存储，它采用 [IEEE 754](https://zh.wikipedia.org/wiki/IEEE_754) 标准定义的 64 位浮点格式表示数字，如下图

![](https://qiniu.isboyjc.com/PictureBed/other/image-20201121184413568.png)

- 第 63 位即 1 位符号位 S （sign）

- 52 ～ 62位即 11 位阶码 E （exponent bias）

- 0 ～ 51 位即 52 位尾数 M（Mantissa）

符号位也就是上文说的，表示正负，0 为正，1 为负

符号位我们比较好理解，那么什么是尾数什么又是阶码呢？



## 什么是尾数

为了方便解释，我们直接使用例子，来看十进制数 5.2 的尾数

首先，我们把它整数部分和小数部分依次转为二进制，不过多重复这个过程，结果如下

```js
101.00110011... // 小数部分 0011 无限循环
```

一个浮点数的表示方式其实有很多，但规范中一般使用科学计数法，就像上面的 `101.00110011...` ，我们会使用 `1.0100110011.. * 2^2` 这种只留一位整数的表达方式，我们称之为规格化

二进制中只有 0 与 1，按照科学计数法，除了数字 0 ，其余所有规格化的数字首位只可能是1，对此 IEEE 754 直接省略了这个默认的 1 用来增加存储值的范围，所以有效尾数实际上是有 `52 + 1 = 53` 位的

上文说尾数即表达的是数字的小数部分，也就是说二进制数值 `1.0100110011.. * 2^2` 的尾数是 `0100110011...`，因为它是个无限循环小数，所以我们取最大 52 即可，剩余的就截断了，这样就会造成一定的精度损失，这也是为什么 JS 中 `0.1 + 0.2 != 0.3` 的原因，如果尾数不足 52 位则在后面补 0 即可

我们可能会疑惑，为什么除了 0 之外的数字转二进制后首位都是 1，比如 `0.0101` 这种 `0 < 值 < 1` 的二进制小数首位不就是 0 吗，我们说了是 规格化之后的，二进制小数 `0.0101` 在规格化之后是 `1.01 * 2^-2` ，所以省略首位 1 并不会混淆



## 什么是阶码

首先，我们要知道

阶码  =  阶码真值  +  偏移量 1023，偏移量 = `2^(k-1)-1`，k 表示阶码位数

阶码真值即为科学记数法中指数真实值的 2 进制表达，它表明了小数点在尾数中的位置

那么为什么阶码真值与偏移量相加得到阶码呢？

简单理解，阶码真值是实际指数中的二进制值，而阶码是指数偏移之后保存起来的二进制数值

还拿上面数值 5.2 来说，它的规格化二进制为 `1.0100110011.. * 2^2` ，2 的 2 次方，也就是说它的阶码真值为 2 ，那么加上偏移量 1023 即 1025，转二进制后的 11位阶码即为 `10000000001` 

那么为什么要偏移呢？



## 为什么阶码有偏移量 1023？

此时你可能会比较好奇为什么阶码会有偏移量这个概念，我们来推导一遍即可

11位的阶码，那么阶码可以存储的二进制值范围为 0～2047，除去 0 与 2047 两个非规格化情况（非规格化下面会说），变成 1～2046，这里指的是正数，因为还有负数，那指数范围就是 -1022～1023，如果没有偏移量的存在，指数就需引入符号位，因为有负数，还需要引入补码，无疑会使计算更加复杂，为了简化操作，才使用无符号的阶码，并引入偏移量的概念



## 不同情况下的阶码 E

我们上面提到过规格化和非规格化的概念，那么它们是什么呢

规格化的情况其实就是上面我们说的一般情况，因为阶码不能为 0 也不能为 2047，所以指数不能为 -1023，也不会为 1024，只有这种情况尾数才会有隐含位 1 即默认忽略的那一位，如下

```js
S + (E!=0 && E!=2047) + 1.M
```

那么非规格化就是阶码全为 0，指数为 -1023 的特殊情况了，如果尾数全为 0，则浮点数表示正负 0，否则表示那些非常的接近于 0.0 的数，如下

```js
S + 00000000000 + M
```

非规格化指的是阶码全为 0 ，那么表示了还有一种情况阶码全部为 1，指数就是 1024，在这种情况下，如果尾数全部为 0 ，那就是无穷大，若尾数不等于 0，那就是我们常说的 NaN 了

```js
无穷大：S + 111 11111111 + 00000000...

NaN：S + 111 11111111 + (M!=0)
```



## 测试一哈

可能大家还是有些迷惑，最好反复看一看，那么歇一歇脑子，接下来我们来一个小测试，计算一下十进制数 -15.125 在 JS 内存中的二进制表达方式是多少，动手试一试吧，做完再看答案

｜

｜

都看到这了，动动小手，点个赞吧 😄 

｜

｜

如上，求十进制数 -15.125 在 JS 内存中的二进制

首先，由于是负数，那么符号为就是 1

接着，将 15.125 的整数部分 15 和小数部分 0.125 分别转为二进制，计算过程不叙述了，整数除 2 取余逆序排列，小数乘 2 取整顺序排列，结果合到一块为 `1111.001` 

按照科学技术法规格化结果为 `1.111001 * 2^3` 

再接下来，计算阶码，3（阶码真值）+ 1023（偏移量）= 1026

将 1026 转为 11 位二进制 `100 0000 0010` ，即为阶码

尾数即规格化结果数去掉整数 1 的小数部分 `1110 01`，不足 52 位后补 0 尾数结果为 `1110 0100 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000`

最后，拼接即可

```js
符号位 + 阶码 + 尾数
1 10000000010 1110010000000000000000000000000000000000000000000000
```



## JS中数字范围

如果大家真的理解了上文，那么就会发现数字的范围其实有两个概念，最大正数和最小负数，最小正数和最大负数

而最终的数字范围即 `最小负数~最大负数` 并上 `最小正数~最大正数`

从S、E、M即数符、阶码、尾数三个维度看，S 代表正负，阶码 E 的值远大于尾数 M 的个数，所以阶码  E 决定大小，尾数 M 决定精度

So，我们从阶码 E 入手分析

规格化下，当 E 最大值时，2046（最大阶码） - 1023（偏移量） = 1023（阶码真值）即 `011 11111111` 

从阶码 E 的最大值求出的指数（阶码真值）来看，我们可以得到的数值范围是 `-2^1023 ~ 2^1023`，使用 JS 的求指函数 `Math.pow(2,1023)` 得出结果是 `8.98846567431158e+307`，那么如果尾数是 `1.11111111...`，则它就无限接近于 2，我们不算这么准确，就用 `8.98846567431158 x 2`   再合上原来的指数，约等于 `1.797693134862316e+308`

大家还记得我们用 JS 常量 `Number.MAX_VALUE` 求到的最大数字值吗，现在就可以在控制台输出一下，即 `1.7976931348623157e+308`，和我们估算出来的值非常相近（因为为了简单我们把规格化的数字约等于了 2 来计算，算出的数值其实是大了一点的）

所以数字的最大正数和最小负数范围如下

```js
1.7976931348623157e+308 ~ -1.7976931348623157e+308
```

如果超过这个值，则数字太大就溢出了，在 JS 中会显示 `Infinity` 或 `-Infinity`，即无穷大与无穷小，学名叫做正向溢出

上面说的是规格化下，那么非规格化下，也就是指数为 0（最小阶码） - 1023 (偏移量) =  - 1023，即 `10000000001` 

从指数来看，我们可以得出最小值是 `2^-1023` ，当如果尾数是 `0.00000...001` 

也就是尾数不为 0 的情况，52 位尾数相当于小数点还能虚拟化的向右移动51，可以取得更小的 `2^-51` ,  所以最小值为为 `2^-1074`，我们再来计算下 `Math.pow(2,-1074)` 结果约等于  `5e-324` 

而 JS 最小值常量 `Number.MIN_VALUE` 得出的值就是是 `5e-324` 

所以数字的最小正数和最大负数范围即如下

```js
5e-324 ~ -5e-324
```

如果存了一个数值比可表示的最小数还要小，就显示成 0，学名反向溢出





## JS中整数的范围

和数字大小不同，数字可以有小数，但是整数就只是单纯整数

我们从尾数 M 来分析，精度最多是 53 位（包含规格化的隐含位 1 ），精确整数的范围其实就是 M 的最大值，即 `1.11111111...111` ，也就是 `2^53-1` ， 使用 JS 函数 `Math.pow(2,53)-1` 计算得到数字 `9007199254740991`

所以整数的范围其实就是

```js
-9007199254740991 ~ 9007199254740991
```

我们也可以使用 JS 内部常量来获取下最大与最小安全整数

```js
Number.MIN_SAFE_INTEGER  // -9007199254740991
Number.MAX_SAFE_INTEGER  //  9007199254740991
```

恰好与我们所求一致

那么我们说如果整数是这个范围内，则是安全整数

一个整数是否是安全整数可以使用 JS 的内置方法 `Number.isSafeInteger()` 来验证
