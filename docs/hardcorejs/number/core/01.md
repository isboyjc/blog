# 二进制

对于计算机只能存储二进制，想必是大家耳熟能详的知识了

我们都知道在计算机内部数据的存储和运算都采用二进制，是因为计算机是由很多晶体管组成的，而晶体管只有2种状态，恰好可以用二进制的 0 和 1 表示，并且采用二进制可以使得计算机内部的运算规则简单，稳定性高，但是由于我们平常并不直接使用二进制，所以可能有小伙伴能给十进制转二进制都忘了，这里就简单介绍一下，当作回顾



## 整数转二进制

关于十进制整数转二进制，其实很简单，记住一个秘诀，就可以了

```js
除 2 取余，逆序排列
```

就是用 2 整除十进制数，得到商和余数，再用 2 整除商，得到新的商和余数，一直重复直至商等于 0，将先得到的余数作为二进制数的高位，后得到的余数作为二进制数的低位，依次排序即可

例如，我们将十进制 55 转换为 2 进制

```js
55 % 2 // 商 27 余 1
27 % 2 // 商 13 余 1
13 % 2 // 商  6 余 1
6  % 2 // 商  3 余 0
3  % 2 // 商  1 余 1
1  % 2 // 商  0 余 1
```

取余逆序，那么十进制 55 转 2 进制的结果就是 `110111` 

二进制一个数值是 1 位，也就是 1 比特（bit），那么如果我们需要得到 8 位二进制，那就在转换结果前补 0 即可

如十进制 55 的 8 位二进制即 `00110111`，那么可能还会有人为如果是 4 位怎么办呢，4 位是存不了 55 这么大值的，溢出了



## 小数转二进制

可能还有人不了解十进制小数是怎么转二进制的，其实也有方法口诀

```js
乘 2 取整，顺序排列
```

用 2 乘十进制小数，可以得到积，将积的整数部分取出，再用 2 乘余下的小数部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的整数部分为零，或者整数部分为1，此时 0 或 1 为二进制的最后一位或者达到所要求的精度为止，然后把取出的整数部分按顺序排列起来，先取的整数作为二进制小数的高位有效位，后取的整数作为低位有效位



例如，将十进制小数 `0.625` 转二进制

```js
0.625 * 2 = 1.250 // 取整数 1
0.25  * 2 = 0.50  // 取整数 0
0.5   * 2 = 1			// 取整数 1 并结束
```

取整顺序，那么十进制小数 `0.625` 的二进制即为 `0.101` 



如果该十进制值是一个大于 1 的小数，那么整数部分和小数部分分别取二进制再拼接即可



例如，将十进制小数 `5.125` 转二进制

我们先计算整数 5 的二进制

```js
5 % 2 // 商  2 余 1
2 % 2 // 商  1 余 0
1 % 2 // 商  0 余 1
```

那么 5 的二进制即 `101`，再来看小数部分

```js
0.125 * 2 = 0.250 // 取整数 0
0.25  * 2 = 0.50  // 取整数 0
0.5   * 2 = 1			// 取整数 1 并结束
```

那么小数部分 `0.125` 的二进制即 `001`，拼接可得出十进制数字 `5.125` 的二进制为 `101.001` 



还会有一种情况，例如十进制小数 `0.1` 取其二进制

```js
0.1 * 2 = 0.2 // 取整数 0
0.2 * 2 = 0.4 // 取整数 0
0.4 * 2 = 0.8 // 取整数 0
0.8 * 2 = 1.6 // 取整数 1
0.6 * 2 = 1.2 // 取整数 1 -> 到此我们看到开始无限循环了
0.2 * 2 = 0.4 // 取整数 0
0.4 * 2 = 0.8 // 取整数 0
...
```

那么它的二进制就是 `0.0001100......` 这样反复循环，这也引出了我们在语言层面的问题，例如 JS 中被人诟病的 `0.1 + 0.2 != 0.3` 的问题，我们后面再说
