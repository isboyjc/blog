# 什么是尾调用、尾递归、蹦床函数?

## 题干

- 函数
  - 尾调用
  - 尾递归
  - 蹦床函数

## 题解

### 尾调用

尾调用是指一个函数的最后一个动作是返回另一个函数的调用结果。

错误示范：

```js
// 情况一
function f(x){
  let y = g(x);
  return y;
}

// 情况二
function f(x){
  return g(x) + 1;
}

// 情况三
function f(x){
  g(x);
}

// 情况四 等同于情况三
function f(x){
  g(x);
  return undefined;
}
```

尾调用不一定出现在函数尾部，只要是最后一步操作即可。

```js
function f(x) {
  if (x > 0) {
    return m(x)
  }
  return n(x);
}
```

上面代码中，函数 `m` 和 `n` 都属于尾调用，因为它们都是函数 `f` 的最后一步操作。

为什么推荐尾调用呢？

我们都知道，函数调用会在内存形成一个 “调用记录”，又称 “调用帧”（`call frame`），保存调用位置和内部变量等信息。如果在函数 `A` 的内部调用函数 `B`，那么在 `A` 的调用帧上方，还会形成一个 `B` 的调用帧。等到B运行结束，将结果返回到 `A`，`B` 的调用帧才会消失。如果函数B内部还调用函数 `C`，那就还有一个 `C` 的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（`call stack`）。

尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。

```js
function f() {
  let m = 1;
  let n = 2;
  return g(m + n);
}
f();

// 等同于
function f() {
  return g(3);
}
f();

// 等同于
g(3);
```

尾调用优化（`Tail call optimization`）是指编译器针对这种情况进行的优化，将尾调用转换为跳转指令，从而减少函数调用的开销。

上面代码中，如果函数 `g` 不是尾调用，函数f就需要保存内部变量 `m` 和 `n` 的值、`g` 的调用位置等信息。但由于调用 `g` 之后，函数 `f` 就结束了，所以执行到最后一步，完全可以删除 `f(x)` 的调用帧，只保留 `g(3)` 的调用帧。

这就叫做尾调用优化，即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是 “尾调用优化” 的意义。

只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行尾调用优化。

注：目前只有 `Safari` 浏览器支持尾调用优化，`Chrome` 和 `Firefox` 都不支持。


### 尾递归

函数调用自身，称为递归。如果尾调用自身，就称为尾递归。

递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生 “栈溢出” 错误（`stack overflow`）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生 “栈溢出” 错误。

🌰：

计算 `Fibonacci` 数列

```js
function Fibonacci (n) {
  if ( n <= 1 ) {return 1};

  return Fibonacci(n - 1) + Fibonacci(n - 2);
}

Fibonacci(10) // 89
Fibonacci(100) // 超时
Fibonacci(500) // 超时
```

改写成尾递归，只保留一个调用记录，如下

```js
function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n <= 1 ) {return ac2};

  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}

Fibonacci2(100) // 573147844013817200000
Fibonacci2(1000) // 7.0330367711422765e+208
Fibonacci2(10000) // Infinity

```

尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。

尾递归优化是指编译器针对这种情况进行的优化，将递归转换为循环，从而避免栈溢出等问题。`ES6` 明确规定，所有 `ECMAScript` 的实现，都必须部署尾调用优化。

也就是说，在 `ES6` 中只要使用尾递归，就不会发生栈溢出（或者层层递归造成的超时），相对节省内存。

递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持 “尾调用优化” 的语言（比如 `Lua`，`ES6`），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。


注意：

`ES6` 的尾调用优化只在严格模式下开启，正常模式是无效的。这是因为在正常模式下，函数内部有 `arguments`、`caller` 两个变量，可以跟踪函数的调用栈。尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。

### 蹦床函数

尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。

它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用 “循环” 换掉 “递归”。

下面是一个正常的递归函数。

```js
function sum(x, y) {
  if (y > 0) {
    return sum(x + 1, y - 1);
  } else {
    return x;
  }
}

sum(1, 100000)
// Uncaught RangeError: Maximum call stack size exceeded(…)
```

上面代码中，`sum` 是一个递归函数，参数 `x` 是需要累加的值，参数 `y` 控制递归次数。一旦指定 `sum` 递归 `100000` 次，就会报错，提示超出调用栈的最大次数。

蹦床函数（`trampoline`）可以将递归执行转为循环执行。

```js
function trampoline(f) {
  while (f && f instanceof Function) {
    f = f();
  }
  return f;
}
```

上面就是蹦床函数的一个实现，它接受一个函数 `f` 作为参数。只要 `f` 执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。

然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。

```js
function sum(x, y) {
  if (y > 0) {
    return sum.bind(null, x + 1, y - 1);
  } else {
    return x;
  }
}
```

上面代码中，`sum` 函数的每次执行，都会返回自身的另一个版本。

现在，使用蹦床函数执行 `sum`，就不会发生调用栈溢出。

```js
trampoline(sum(1, 100000))
// 100001
```

蹦床函数并不是真正的尾递归优化，下面的实现才是。

```js
function tco(f) {
  var value;
  var active = false;
  var accumulated = [];

  return function accumulator() {
    accumulated.push(arguments);
    if (!active) {
      active = true;
      while (accumulated.length) {
        value = f.apply(this, accumulated.shift());
      }
      active = false;
      return value;
    }
  };
}

var sum = tco(function(x, y) {
  if (y > 0) {
    return sum(x + 1, y - 1)
  }
  else {
    return x
  }
});

sum(1, 100000)
// 100001
```

上面代码中，`tco` 函数是尾递归优化的实现，它的奥妙就在于状态变量 `active`。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归 `sum` 返回的都是 `undefined`，所以就避免了递归执行；而 `accumulated` 数组存放每一轮 `sum` 执行的参数，总是有值的，这就保证了 `accumulator` 函数内部的 `while` 循环总是会执行。这样就很巧妙地将 “递归” 改成了 “循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。

## 扩展

[阮一峰 ES6教程 - 函数的扩展](https://es6.ruanyifeng.com/#docs/function)