# JS 中 0.1+0.2 != 0.3？

## 题干

```js
console.log(0.1+0.2) // 0.30000000000000004
```

## 题解

这个问题的原因是浮点数运算的精度问题。

在 `JS` 中，数字不分整数和浮点型，所有的数字都是使用浮点型类型来存储，它采用 [IEEE754标准](https://zh.wikipedia.org/wiki/IEEE_754) 定义的 64 位浮点格式表示数字。


在计算机运行过程中，需要将数据转化成二进制，然后再进行计算。但是，浮点数在二进制中不能精确地表示 `0.1` 和 `0.2` 这样的小数。因此，当用 `JS` 计算 `0.1+0.2` 时，实际上是在计算两个近似值的和，而不是真正的 `0.1` 和 `0.2`。这就导致了一些舍入误差，使得结果不等于 `0.3`。


为了理解为什么 `0.1` 不能用 `64` 位的浮点数准确地表示，你必须了解二进制。二进制是一种只有 `0` 和 `1` 两种数字的进制，它可以用来表示任何十进制的数字。例如，十进制的 `5` 可以用二进制的 `101` 来表示，十进制的 `10` 可以用二进制的 `1010` 来表示。但是，对于一些十进制的小数，例如 `0.1`，它们在二进制中是无限循环的。就像十进制中无法用有限位数来表示 `1/3`（0.333…）一样，二进制中也无法用有限位数来表示 `1/10`（0.0001100110011…）。

因此，当 `JS` 要存储一个小数时，它必须对它进行舍入，所以它们的尾数部分都会存在截断误差，只能是近似值，以适应 `64` 位的空间。这就会造成一些精度损失，使得存储的值和真实的值有一些微小的差别。

例如，`JS` 中存储的 `0.1` 和 `0.2` 转成二进制如下：

```js
// 0.1转二进制尾数截断后
0.1000000000000000055511151231257827021181583404541015625

// 0.2转二进制尾数截断后
0.200000000000000011102230246251565404236316680908203125

// 0.1+0.2
0.3000000000000000444089209850062616169452667236328125
```


如上，当你把这两个值相加时，得到的结果不是真正的 `0.3`。这就是为什么 `JS` 中 `0.1+0.2` 不等于 `0.3` 的原因。




## 扩展

### 怎样让 0.1+0.2 等于0.3

- 使用整数代替小数进行运算，然后再转换回小数。例如，把 `0.1` 和 `0.2` 乘以 `10` 变成整数 `1` 和 `2`，相加得到 `3`，再除以 `10` 得到 `0.3`。

- 使用一个较小的误差范围（`epsilon`）来判断两个浮点数是否相等。例如，如果两个浮点数之差的绝对值小于一个很小的数（如 `Number.EPSILON`），则认为它们相等。

- 使用一些专门处理浮点数运算的库或工具，如 `decimal.js` 或 `bignumber.js` 等。

## 相关

[「硬核JS」数字之美](https://juejin.cn/post/6897949585558208525)
