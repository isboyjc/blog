# 简单的Vue

## 核心篇

#### MVC、MVP和MVVM？

- 这三者都是框架模式，它们设计的目标都是为了解决Model和View的耦合问题。

- MVC模式出现较早主要应用在后端，如Spring MVC、ASP.NET MVC等，在前端领域的早期也有应用，如Backbone.js。它的优点是分层清晰，缺点是数据流混乱，灵活性带来的维护性问题。

- MVP模式在是MVC的进化形式，Presenter作为中间层负责MV通信，解决了两者耦合问题，但P层过于臃肿会导致维护问题。

- MVVM模式在前端领域有广泛应用，它不仅解决MV耦合问题，还同时解决了维护两者映射关系的大量繁杂代码和DOM操作代码，在提高开发效率、可读性同时还保持了优越的性能表现



#### v-show 与 v-if 有什么区别？

- v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块

- v-show 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 `display` 属性进行切换

v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景

v-show 不支持 `<template>` 元素，也不支持 v-else



#### v-if 和 v-for 哪个优先级更高？

- v-for优先于v-if被解析

- 如果同时出现，每次渲染都会先执行循环再判断条件，无论如何循环都不可避免，浪费了性能

- 要避免出现这种情况，则在外层嵌套template，在这一层进行v-if判断，然后在内部进行v-for循环

- 如果条件出现在循环内部，可通过计算属性提前过滤掉那些不需要显示的项



#### Vue组件data为什么是函数而Vue的根实例则没有此限制？

Vue组件可能存在多个实例，如果使用对象形式定义data，则会导致它们共用一个data对象，那么状态变更将会影响所有组件实例，这是不合理的；采用函数形式定义，在initData时会将其作为工厂函数返回全新data对象，有效规避多实例之间状态污染问题

而根实例只能有一个，不需要担心这种情况



#### Vue中key的作用和工作原理？

 key的作用主要是为了高效的更新虚拟DOM，其原理是vue在patch过程中通过key可以精准判断两个节点是否是同一个，从而避免频繁更新不同元素，使得整个patch过程更加高效，减少DOM操作量，提高性能。

另外，若不设置key还可能在列表更新时引发一些隐蔽的bug

Vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果。



#### Vue通信方式？

- props （父传子，常用）
- $emit/\$on | 事件总线EventBus（父子、子父、跨层皆可）
- $parent/\$children/\$ref 获取组建实例（父子、子父可，不可跨层）
- $attrs/\$listeners（皆可）
  - $attrs 里存放的是父组件中绑定的非 Props 属性，\$listeners 里存放的是父组件中绑定的非原生事件
- provide/inject（父子、跨层都可，不是响应式）
- 通过根实例对象 $root 通信 （皆可，全局可修改）
- vuex（皆可） 



#### Vue组件模版为什么只能有一个根元素？

- new Vue({el:'#app'})，如果同时设置多个入口，那vue就不知道哪一个才是入口类

- 单文件组件中，一个vue组件就是一个vue实例，template下元素 div 就是树结构中的根，多个根递归就需要源码额外做操作了

- diff算法要求的，源码中，patch.js里patchVnode()。 



#### Vue中watch与computed的区别？

 watch 是属性监听器，一般用来监听属性的变化（也可以用来监听计算属性函数），并做一些逻辑

computed 对于任何复杂逻辑或一个数据属性在它所依赖的属性发生变化时，会重新计算当前计算属性的值

watch更通用，源码中computed底层来自于$watch，但做了更多，例如缓存



#### Vue父组件监听子组件生命周期（hook）？

源码中生命周期函数是通过 `callHook` 函数去调用的， `callHook` 函数中在 `vm._hasHookEvent` 为 `true`的情况下，有着 `hook:` 特殊前缀的事件，会在对应的生命周期当中执行

组建中监听事件解析后会使用 `$on` 注册事件回调，使用 `$on` 或 `$once` 监听事件时，如事件名以 `hook:` 作为前缀，那这个事件会被当做 `hookEvent`，注册事件回调的同时，`vm._hasHookEvent` 会被置为 `true`，后当使用 `callHook` 调用生命周期函数时，由于 `_hasHookEvent` 为 `true`，所以会 `$emit('hook:xxx')`，注册的生命周期函数就会执行

- 在模板中通过 `@hook:created` 这种形式
- `vm.$on('hook:created', cb)` 或者 `vm.$once('hook:created', cb)`。



#### Vue声明周期理解？

- beforeCreate
  - 在实例初始化之后，数据观测（data observe）和event/watcher事件配置之前被调用，这时无法访问data及props等数据

- created
  - 在实例创建完成后被立即调用，此时实例已完成数据观测（data observer），属性和方法的运算，watch/event事件回调，挂载阶段还没开始， $el 尚不可用
- beforemount
  - 在挂载开始之前被调用，相关的render函数首次被调用
- mounted
  - 实例被挂载后调用，这时el被新创建的vm. \$el 替换，若根实例挂载到了文档上的元素上，当mounted被调用时 vm.$el 也在文档内。注意mounted不会保证所有子组件一起挂载
- beforeupdata
  - 数据更新时调用，发生在虚拟dom打补丁前，这时适合在更新前访问现有dom，如手动移除已添加的事件监听器。
- updated
  - 在数据变更导致的虚拟dom重新渲染和打补丁后，调用该钩子。当这个钩子被调用时，组件dom已更新，可执行依赖于dom的操作。多数情况下应在此期间更改状态。 如需改变，最好使用watcher或计算属性取代。注意updated不会保证所有的子组件都能一起被重绘
- beforedestory
  - 在实例销毁之前调用。在这时，实例仍可用
- destroyed
  - 实例销毁后调用，这时vue实例的所有指令都被解绑，所有事件监听器被移除，所有子实例也被销毁。



#### Vue父子组件生命周期调用顺序？

组件的调用顺序都是 `先父后子`,渲染完成的顺序是 `先子后父` 

组件的销毁操作是 `先父后子`，销毁完成的顺序是 `先子后父` 

**加载渲染过程**

```
父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount- >子mounted->父mounted
```

**子组件更新过程**

```
父beforeUpdate->子beforeUpdate->子updated->父updated
```

**父组件更新过程**

```
父 beforeUpdate -> 父 updated
```

**销毁过程**

```
父beforeDestroy->子beforeDestroy->子destroyed->父destroyed
```




#### Vue单向数据流理解？

所有的 prop 都使得其父子 prop 之间形成了一个**单向下行绑定**：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解，也是为了组件间更好的解耦

在开发中可能有多个子组件依赖于父组件的某个数据，假如子组件可以修改父组件数据的话，一个子组件变化会引发所有依赖这个数据的子组件发生变化

v-model在使用的时候很像双向绑定的（实际上也是。。。），但其实也是单项数据流，v-model 只是语法糖而已。在给 input 元素添加 v-model 属性时，默认会把 value 作为元素的属性，然后把 'input' 事件作为实时传递 value 的触发事件



#### Vue组件化理解？

- 组件系统是 Vue 核心特性之一，它使开发者使用小型、独立和通常可复用的组件构建大型应用；组件化开发能大幅提高应用开发效率、测试性、复用性等

- 组件使用按分类有：页面组件、业务组件、通用组件

- vue的组件是基于配置的，我们通常编写的组件是组件配置而非组件，框架后续会生成其构造函数，它们基于VueComponent，扩展于Vue

- vue中常见组件化技术有：属性prop，自定义事件，插槽等，它们主要用于组件通信、扩展等

- 合理的划分组件，有助于提升应用性能

- 组件应该是高内聚、低耦合的

- 遵循单向数据流的原则



#### Vue组件设计原则？

- 容错处理, 这个要做好, 极端场景要考虑到, 不能我传错了一个参数就挂了
- 缺省值(默认值)要有, 一般把应用较多的设为缺省值
- 颗粒化, 把组件拆分出来
- 一切皆可配置, 如有必要, 组件里面使用中文标点符号, 还是英文的标点符号, 都要考虑到，灵活性更高
- 场景化, 如一个dialog弹出, 还需要根据不同的状态封装成success, waring, 等
- 有详细的文档/注释和变更历史, 能查到来龙去脉, 新版本加了什么功能是因为什么
- 组件名称, 参数prop, emit, 名称设计要通俗易懂, 最好能做到代码即注释这种程度
- 可拓展性, 前期可能不需要这个功能, 但是后期可能会用上, 要预留什么, 要注意什么, 心里要有逼数
- 规范化,我这个input组件, 叫`on-change`, 我另外一个select组件叫`change`, 信不信老子捶死你
- 分阶段: 不是什么都要一次开发完成做到极致，要看具体业务，不能自己给自己加戏



#### VDOM的理解及优缺？

虚拟 DOM 的实现原理主要包括以下 3 部分：

- 用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象
- diff 算法 — 比较两棵虚拟 DOM 树的差异
- pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树

优点：

- 保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；

- 无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率

- 跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等

缺点：

- 无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化



#### Vue中的diff？

diff算法是虚拟DOM技术的必然产物：通过新旧虚拟DOM作对比（即diff），将变化的地方更新在真实DOM上；另外，也需要diff高效的执行对比过程，从而降低时间复杂度为O(n)。

vue 2.x中为了降低Watcher粒度，每个组件只有一个Watcher与之对应，只有引入diff才能精确找到发生变化的地方。

vue中diff执行的时刻是组件实例执行其更新函数时，它会比对上一次渲染结果oldVnode和新的渲染结果newVnode，**此过程称为patch**。

diff过程整体遵循深度优先、同层比较的策略；两个节点之间比较会根据它们是否拥有子节点或者文本节点做不同操作；比较两组子节点是算法的重点，首先假设头尾节点可能相同做4次比对尝试，如果没有找到相同节点才按照通用方式遍历查找，查找结束再按情况处理剩下的节点；借助 key 通常可以非常精确找到相同节点，因此整个 patch 过程非常高效。



#### Vue中的patch算法？

1. 调用patch函数比较Vnode和OldVnode,如果不一样直接return Vnode即将Vnode真实化后替换掉DOM中的节点

2. 如果OldVnode和Vnode值得进一步比较则调用patchVnode方法进行进一步比较，分为以下几种情况：

- Vnode有子节点，但是OldVnode没有，则将Vnode的子节点真实化后添加到真实DOM上

- Vnode没有子节点，但是OldVnode上有，则将真实DOM上相应位置的节点删除掉
- Vnode和OldVnode都有文本节点但是内容不一样，则将真实DOM上的文本节点替换为Vnode上的文本节点
- Vnode和OldVnode上都有子节点，需要调用updateChildren函数进一步比较
- updateChildren比较规则
  - 提取出Vnode和OldVnode中的子节点分别为vCh和OldCh，并且提出各自的起始和结尾变量标记为 oldS oldE newS newE
  - 如果是oldS和newE匹配上了，那么真实dom中的第一个节点会移到最后
  - 如果是oldE和newS匹配上了，那么真实dom中的最后一个节点会移到最前，匹配上的两个指针向中间移动
  - 如果都没有，在没有key的情况下直接在DOM的oldS位置的前面添加newS，同时newS+1。在有key的情况下会将newS和Oldch上的所有节点对比，如果有相同的则移动DOM并且将旧节点中这个位置置为null且newS+1。如果还没有则直接在DOM的oldS位置的前面添加newS且newS+1
    直到出现任意一方的start>end，则有一方遍历结束，整个比较也结束



#### Vue中v-model原理？

`v-model`本质就是一个语法糖，可以看成是`value + input`方法的语法糖。 可以通过model属性的`prop`和`event`属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性。



#### Vue响应式/双向数据绑定原理？

响应式，意思就是在改变数据的时候，视图会跟着更新

数据劫持结合“**发布-订阅**”模式的方式，通过**Object.defineProperty（）的 set 和 get**，在数据变动时发布消息给订阅者触发监听

每个组件实例都对应一个 **watcher** 实例，它会在组件渲染的过程中把“接触”过的数据关联记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染



#### Vue初始化流程？



#### Vue更新流程？

Vue 在更新 DOM 时是**异步**执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 `Promise.then`、`MutationObserver` 和 `setImmediate`，如果执行环境不支持，则会采用 `setTimeout(fn, 0)` 代替



#### Vue模版编译原理？

简单说，Vue的编译过程就是将`template`转化为`render`函数的过程。会经历以下阶段：

- 生成AST树
- 优化
- codegen

首先解析模版，生成`AST语法树`(一种用JavaScript对象的形式来描述整个模板)。 使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。

Vue的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的DOM也不会变化。那么优化过程就是深度遍历AST树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以`跳过对它们的比对`，对运行时的模板起到很大的优化作用。

编译的最后一步是`将优化后的AST树转换为可执行的代码`。



#### Vue中nextTick的使用场景和原理？



#### Vue中keep-alive的使用场景和原理？



#### Vue.mixin的使用场景和原理？

混入 (mixins) 是一种分 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项

全局混入的执行顺序要前于混入和组件里的方法



#### Vue.extend作用和原理?



#### Vue.set作用和原理?



#### Vue.use作用和原理？

use方法接收一个类型为函数或对象的参数

只是如果参数是对象，那它就必须有一个 install 属性方法

不论参数是函数还是对象，在执行 install 方法或者函数本身的时候都会把构造函数 Vue 作为第一个参数传进去

这样我们在写插件的时候，但写一个函数或者一个有 install 函数属性的对象，都可以接收到构造函数 Vue，也就可以使用它来做一些事情了



#### Vue自定义指令原理?

指令本质上是装饰器，是 vue 对 HTML 元素的扩展，给 HTML 元素增加自定义功能。vue 编译 DOM 时，会找到指令对象，执行指令的相关方法。

自定义指令有五个生命周期（也叫钩子函数），分别是 bind、inserted、update、componentUpdated、unbind

- bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置
- inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)
- update：被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新。
- componentUpdated：被绑定元素所在模板完成一次更新周期时调用
- unbind：只调用一次，指令与元素解绑时调用



#### Vuex理解和原理？

Vuex 通过代码实现了一个单向数据流，在全局拥有一个 `State` 存放数据，当组件要更改 `State` 中的数据时，必须通过 `Mutation` 提交修改信息， `Mutation` 同时提供了订阅者模式供外部插件调用获取 `State` 数据的更新。

而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走` Action` ，但 `Action` 也是无法直接修改 State 的，还是需要通过 `Mutation` 来修改 `State` 的数据。最后，根据 `State` 的变化，渲染到视图上。

- state ： `vuex` 的唯一数据源，如果获取多个 `state` ,可以使用 `...mapState`
- getter : 可以将其理解为计算属性， `getter` 的返回值根据他的依赖缓存起来，依赖发生变化才会被重新计算
- mutation ：更改 `state` 中唯一的方法是提交 `mutation`
- action ： 类似 `mutation`，但它通过提交 `mutation` 修改状态，可异步操作
- module ：当应用变得非常复杂是， `store` 就会变得相当臃肿。vuex 允许我们将 store分割成模块，每个模块拥有自己的 `state,mutation,action,getter` ，甚至是嵌套子模块从上至下进行同样方式分割



#### VueRouter路由模式及实现原理？

vue-router 有 3 种路由模式：hash、history、abstrac

- hash:  使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；
- history :  依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；
- abstract :  支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.

hash 模式核心就是使用 hashChange 事件监听URL hash（URL中#号后面的部分）改变，URL中的 hash 改变不会触发http请求，监听到改变之后重新渲染对应组件，使用API跳转时，其实主要是通过 window.location.hash 以及 window.location.replace 来手动改变路由

history 模式核心是使用 popstate 事件监听浏览器前进后退，使用 pushstate API 以及 replaceState API来手动跳转路由

abstract 模式则是使用数组模拟一个历史调用栈，通过数组API操作调用栈来实现路由



#### Vue函数式组件使用场景和原理？

函数式组件与普通组件的区别:

- 函数式组件需要在声明组件是指定 functional:true
- 不需要实例化，所以没有this,this通过render函数的第二个参数context来代替
- 没有生命周期钩子函数，不能使用计算属性，watch
- 不能通过\$emit 对外暴露事件，调用事件只能通过context.listeners.click的方式调用外部传入的事件
- 因为函数式组件是没有实例化的，所以在外部通过ref去引用组件时，实际引用的是HTMLElement
- 函数式组件的props可以不用显示声明，所以没有在props里面声明的属性都会被自动隐式解析为prop,而普通组件所有未声明的属性都解析到$attrs里面，并自动挂载到组件根元素上面(可以通过inheritAttrs属性禁止)

优点:

- 由于函数式组件不需要实例化，无状态，没有生命周期，所以渲染性能要好于普通组件

- 函数式组件结构比较简单，代码结构更清晰

使用场景：

- 简单的展示组件，作为容器组件使用 比如 router-view 就是一个函数式组件

- “高阶组件”——用于接收一个组件作为参数，返回一个被包装过的组件



#### Vue SSR的理解及优缺？

SSR 即服务端渲染，Vue 在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的 html 片段后再返回给客户端这个过程就叫做服务端渲染

- 优：
  - 更好的 SEO： SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面
  - 更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间

- 缺：
  - 开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境
  - 更多的服务器负载：在 Node.js  中渲染完整的应用程序，显然会比仅仅提供静态文件的  server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略



#### Vue性能优化？

代码层面：

- 路由懒加载
- keep-alive缓存页面
- 使用v-show复用DOM
- v-for 遍历避免同时使用 v-if
- 长列表性能优化
  - 纯粹的数据展示，不会有任何改变，就不需要做响应化
  - 大数据长列表，可采用虚拟滚动，只渲染少部分区域的内容
- Vue 组件销毁会自动解绑它的全部指令及事件监听器，但仅限于组件本身事件，像timer等需beforeDestroy时销毁
- 图片懒加载
- 第三方插件（如element组件）按需引入
- 无状态的组件标记为函数式组件
- 变量本地化（不需要双向绑定的变量本地声明）
- 对SEO有要求就SSR

Webpack层面：

- Webpack 对图片进行压缩
- 减少 ES6 转为 ES5 的冗余代码
- 提取公共代码
- 模板预编译
- 提取组件的 CSS
- 优化 SourceMap
- 构建结果输出分析
- Vue 项目的编译优化

Web技术优化：

- 开启 gzip 压缩
- 浏览器缓存
- CDN 的使用
- 使用 `Chrome Performance` 查找性能瓶颈





#### Vue、React 的区别和联系？

**设计原则：**

Vue的官网中说它是一款渐进式框架，采用自底向上增量开发的设计，Vue在声明式渲染的基础上，还可以为其添加组件系统、路由、状态管理、构建工具等来构建一个完整的框架，但并不需要一上手就把所有东西全用上，这些解决方案相互独立，所以说是渐进式

React主张函数式编程，推崇纯组件，强调单向数据流、数据不可变，而Vue是基于可变数据的，支持双向绑定



**语法：**

Vue推荐 webpack+vue-loader 的单文件组件格式，保留了html、css、js分离的写法，更接近常用的 web 开发方式

React没有模板，直接就是一个渲染函数，中间返回的就是一个虚拟DOM，React推荐的做法是 JSX + inline style，即all in js，JSX实际上就是一套XML语法



**数据流：**

Vue1中父组件和子组件因为 props 是双向绑定所以父子组件间是双向数据流，而组件和DOM之间也是双向的。Vue2 里 props 取消了双向绑定其父子组件之间也变成了单向数据流，但Vue2也提供了用事件的方式去修改父组件，它的组件和 DOM 之间还是双向的

React 从诞生之初就不支持双向绑定，一直提倡单向数据流，称之为 onChange/setState() 模式

一般项目中都会用 Vuex 以及 Redux 等单向数据流的状态管理框架，因此很多时候我们感受不到这一点的区别了



**数据绑定：**

Vue是双向数据绑定，当视图改变更新模型层，当模型层改变更新视图层。它采用数据劫持&发布订阅模式，通过Object.defineProperty对数据进行操作，为数据动态添加了getter与setter方法，获取数据触发getter，设置数据触发setter，从而触发watcher进行数据更改，接着更新试图

React是单向数据流，它的属性不允许更改，状态可更改，组件不允许直接通过 this.state 这种方式更改组件状态，需要通过setState来进行更改。而 setState 是异步的，需要在setState第二个参数（回调函数）中获取更新后的新的内容



#### Vue3新特性？

- 更快
  -  虚拟DOM重写
  - 优化slots的生成
  - 静态树提升
  - 静态属性提升
  - 基于Proxy的响应式系统

- 更小：
  - 通过摇树优化核心库体积，开发时没有使用到的Vue特性不会被打包进代码

- 更容易维护：
  - TypeScript + 模块化

- 更加友好
  - 跨平台：编译器核心和运行时核心与平台无关，使得Vue更容易与任何平台（Web、Android、iOS）一起使用

- 更容易使用
  - 改进的TypeScript支持，编辑器能提供强有力的类型检查和错误及警告
  - 更好的调试支持
  - 独立的响应化模块
  - Composition API



#### Vue3为什么不需要时间切片？

主要还是优缺点的权衡问题

在Web应用程序中，丢帧更新通常是由于 同步的高CPU时间 和 原生DOM更新 造成的

时间切片是在CPU工作期间保持应用响应的一种方式，它只对CPU工作产生影响。因为 DOM的更新必须是同步的，以确保最终DOM状态一致

所以，想象两种丢帧更新的场景：

1. CPU工作时间在16ms以内，但是需要做大量原生DOM更新操作。这种情况下不管有没有使用时间切片，应用依旧会感觉到掉帧
2. CPU任务非常繁重，需要超过16ms的时间。理论上时间切片开始发挥作用了。然而，HCI研究表明，除非它在进行动画，否则对于正常的用户交互，大多数人对于100毫秒内的更新是感觉不到有什么不同的。

也就是说，只有在频繁进行超过100ms的纯CPU任务更新时，时间切片才有实际作用

React经常会出现这种情况：

- React的虚拟DOM操作天生就比较慢，因为它使用了大量的Fiber架构

- React使用JSX来渲染函数相对较于用模板来渲染更加难以优化，模板更易于静态分析

- React Hooks将大部分组件树级优化（即防止不必要的子组件的重新渲染）留给了开发人员，开发人员在大多数情况下需要显式地使用`useMemo`。而且，不管什么时候React接收到了`children`属性，它几乎总要重新渲染，因为每次的子组件都是一棵新的vdom树。也意味着，一个使用Hook的React应用在默认配置下会过度渲染。更糟的是，像`useMomo`这类优化不能轻易地自动应用，因为：
  - 它需要正确的deps数组
  - 盲目地任意使用它可能会阻塞本该进行的更新，类似与`PureComponent`

大多数开发人员都很懒，不会积极地优化他们的应用。所以大多数使用Hook的React应用会做很多不必要的CPU工作，所以react需要时间切片

上面的问题对比Vue来说：

- Vue本质上更简单，因此虚拟DOM操作更快（没有时间切片-> 没有`fiber`-> 更少的开销）

- Vue通过分析模板进行了大量的AOT优化，减少了虚拟DOM操作的基本开销。Vue3原生执行速度甚至比Svelte更快，在CPU上花费时间不到React的1/10

- 智能组件树级优化通过响应式跟踪，将插槽编译成函数（避免子元素重复渲染）和自动缓存内联句柄（避免内联函数重复渲染）。除非必要，否则子组件永远不需要重新渲染。这一切并不需要开发人员进行任何手动优化。这也意味着对于同一个更新，React应用可能造成多个组件重新渲染，但在Vue中大部分情况下只会导致一个组件重新渲染

默认情况下， Vue3应用比React应用花费更少的CPU工作时间， 并且CPU工作时间超过100ms的机会大幅度减少了，除非在一些极端的情况下，DOM可能成为更主要的瓶颈

与此同时，**时间切片或者说并发模式（时间切片即并发模式的一个子特性）还带来了另一个问题**：

时间切片使得框架安排并协调了所有更新，它在优先级、失效、重新实例化等方面产生了大量额外的复杂性。所有这些逻辑处理都不可能被`tree-shaken`，这将导致运行时基线的大小膨胀。即使包含了`Suspense`和所有的`tree-shaken`，Vue 3的运行时仍然只有当前React + React DOM的1/4大小

时间切片提供一个新方法解决某一类问题(尤其是相关协调异步状态转换),但时间切片解决了React中比其他框架更突出的问题，同时也带来了成本。对于Vue 3来说，这种权衡是不值得的





## 业务篇

#### Vue中watch和created哪个先执行？

Vue生命周期图中，init reactivity 是晚于 beforeCreate 但是早于created的

watch 加了 immediate，应当同init reactivity周期一同执行，早于created

正常的 watch，则是 mounted 周期后触发 data changes 的周期执行，晚于created



#### Vue中v-html怎么解决xss攻击？

v-html最终是调用 `innerHTML`  将其 `value` 插入对应元素

所以，复写 html 指令，将其 value 值使用 xss 包过滤内容即可



#### Vue中created与activated区别？

created：在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，property 和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el property 目前尚不可用

activated：在路由设置 `<keep-alive></keep-alive>` 时，才会有这个生命周期。在被 keep-alive 缓存的组件激活时调用



#### Vue中如何解决Sass无法解析深度作用选择器 `>>>` ?

可以使用 `/deep/` 或 `::v-deep` 操作符取而代之——两者都是 `>>>` 的别名，同样可以正常工作



#### Vue中为什么v-for的key不推荐使用index？

使用 `index` 在插入数据或者删除数据的时候，会导致后面的数据的key绑定的index变化，进而导致从新渲染，效率会降低

key应该绑定你v-for循环数据中的唯一值，这样就会大大减少渲染次数，数据更新时就不用一一替换，从而使用插入新数据的算法s



#### 什么是预渲染？和SSR区别是什么？



#### Vue中批量引入组件？

使用 `require.context` 或 `import` 函数 



#### Vue中定义全局方法？

- 第一种：挂载到Vue的prototype上。把全局方法写到一个文件里面，然后for循环挂载到Vue的prototype上，缺点是调用这个方法的时候没有提示

- 第二种：利用全局混入mixin，因为mixin里面的methods会和创建的每个单文件组件合并。这样做的优点是调用这个方法的时候有提示





# 前端性能优化
