# 「前端工程四部曲」组件化浅谈

## 写在前面

此文我们主要介绍前端工程化中的组件化，就是我们平常不管是面试还是和朋友聊技术时都津津乐道的组件化思想，如小标题，本文分别以组件化的产生（起源）、什么是组件化、组件化与模块化的区别、现代框架中的组件化以及如何设计一个组件这几个角度来阐述组件化，文章不长，希望可以让更多对组件化概念不清晰的同学加深理解。



## 组件化起源

开发时，不知道你有没有遇到过，当页面逻辑越来越多、代码越来越庞大，写到后面前面的逻辑基本都忘了，很容易造成牵一发而动全身这种现象。或者是同样的逻辑在多个地方反复写，每次改动就要同时改很多地方，甚至会有遗漏从而产生BUG。。

- 项目复杂度增加，单个页面/单个文件需要处理的内容过多
- 重复或类似功能造成的重复性劳动
- 页面结构不清晰，逻辑混乱

随着前端项目复杂度的急剧增加，上面说的问题在开发中很容易遇到，这也是前端组件化出现的原因。



## 什么是组件化

组件化并不是前端所特有的，一些其他的语言或者桌面程序等，都具有组件化的先例。确切的说，只要有 UI 层的展示，就必定有可以组件化。反向来看，从 UI 拆分下来的每个包含模板、样式、逻辑功能完善的结构单元，我们就可称之为组件。

组件化的工程的核心思想是分治，其次是复用，合理的组件化可以使系统工程分治到独立的更小的工程中去，颗粒度越细，组织形式越松散，开发人员之间的开发就不会产生过多的依赖，提高开发效率，同时整个项目的维护也变得简单可行。

可以说页面上所有的东西都是组件，而整个页面就是一个大型组件，可以拆成若干个中型组件，然后中型组件还可以再拆，拆成若干个小型组件，小型组件也可以再拆，直到拆成DOM元素为止，DOM元素可以看成是浏览器自身的组件，作为组件的基本单元。

传统前端框架/类库的思想是先组织DOM，然后把某些可复用的逻辑封装成组件来操作DOM，是DOM优先；而组件化框架/类库的思想是先来构思组件，然后用DOM这种基本单元结合相应逻辑来实现组件，是组件优先。这是两者本质的区别。

其次，组件化实际上是一种按照模板、样式、逻辑三位一体的形式对面向对象的进一步抽象，所以我们除了封装组件本身，还要**合理**处理组件之间的关系，比如继承、扩展、嵌套和包含等，这些关系都可以归为依赖。这里我们看一下依赖，组件存在具体功能的依赖，组件本身之间可能也有依赖关系，但一般不多。组件化开发的原则就是高重用，低依赖，当然这也只是相对而言。

简单来说，组件就是将一段 UI 样式和其对应的功能作为独立的整体去看待，无论这个整体放在哪里去使用，它都具有一样的功能和样式，从而实现复用，这种基于分治思想的整体化构思就是组件化。也不难看出，组件化设计就是为了增加复用性，灵活性，提高系统设计，从而提高我们的开发效率。



## 组件化与模块化

很多人经常会混淆组件化与模块化，首先，组件化不等于模块化。

模块化只是在文件层面上，对代码或资源的拆分。而组件化是在设计层面上，对UI（用户界面）的拆分。

模块最初的目的是将同一类型的代码整合在一起，所以模块的功能相对复杂，但都同属于一个业务。不同模块之间也会存在依赖关系，但大部分都是业务性的互相跳转，从地位上来说它们都是平级的也就是横向分块。

组件最初的目的是代码重用，功能相对单一或者独立。在整个系统的代码层次上位于最底层，被其他代码所依赖，所以说组件化是纵向分层。

因为从代码组织层面上来区分，组件化开发是纵向分层，模块化开发是横向分块，所以模块化并没有要求一定组件化。也就是说我们可以只做模块化开发，而不做组件化开发。那这样的结果是什么样的呢？就是说我们的代码完全不考虑代码重用，只是把相同业务的代码做内聚整合，不同模块之间还是存在大量的重复代码。这样的成果也算是做到了模块化，只不过我们一般不会这样而已。

和组件模块近似的一对概念是库和框架。库的概念偏近于代码的堆集，是分层的概念，所以对应组件化。框架是结构化的代码，所以应用于模块化。组件是骨，模块是肉，就是这个道理。



## 框架中的组件化

我们说不管是前端组件化还是后端的组件化，组件化设计就是为了增加复用性，灵活性，提高系统设计，从而提高我们的开发效率。

组件化思想可以分为两个方面，一个是其所支持的组件系统，定义了我们书写、加载以及使用组件的方式。另一个就是常规意义上组件设计。比如想实现一个网站的头部，可以把头部单独拿出来进行封装，根据不同页面或者说业务要求，可以灵活定制不同的头部，结构一致，颜色或展示等不同。这样就可以在不同的页面进行灵活的复用，后期如果头部结构有大的变动，可以只修改该头部组件就好了。这说的就是第二种常规组件设计。同时我们觉得这个概念很熟悉，其实我们早就在这么干了，比如以前用 jsp 做静态页面生成的时候，就可以利用 jsp 的特殊指令进行引入公共组件。对标现在我们使用框架独有的方式来书写组件，这属于第一种组件系统。不论是第一种还是第二种都属于组件化的一部分。

拿 Vue 举例，组件系统是 Vue 核心特性之一，它使开发者使用小型、独立和通常可复用的组件构建大型应用，组件化开发能大幅提高应用开发效率、测试性、复用性等等。Vue 的组件系统是基于配置的，我们通常编写的组件是组件配置而非组件，框架后续会生成其构造函数，它们基于 VueComponent，又扩展于Vue，通过属性Prop、自定义事件、插槽等等来实现组件通信、扩展。这属于第一种定义组件化思想的组件系统。

那平常我们开发中可以按照使用、状态、展示形式来为组件分类，在开发时进行合理的组件划分，遵循组件单向数据流的原则开发出高内聚、低耦合、可复用的组件，这就属于第二种组件化思想的组件设计。

刚刚说到组件分类，不得不说，在设计组件时，我们最首要的就是要先确定该组件属于哪一类组件，然后再根据组件的类别详细的设计该组件内容，所以一定要弄明白组件的分类方式，这对页面间的组件划分、组件间的解藕是大有裨益的。



## 如何设计一个组件？

### 灵魂5问：是否有设计该组件的必要？

设计一个组件前，其实我们更应该做的是问自己这个组件到底有没有设计的必要，如果你自己不太清楚，那可以先套模版问自己下面几个问题来做到心中有数，再去具体考虑设计问题：

- 是否有足够的结构或逻辑支撑组件设计？
- 此组件会减少开发代码量吗？
- 此组件对性能会不会有影响？
- 此组件有什么好处，有什么坏处？
- 设计此组件的好处大于坏处吗？

自己答完还是有设计组件的想法再去设计组件。。



### 组件分类（定义职能）

上文也说过，确定要设计一个组件，在设计之初，首要的考量就是先为其分类，确定其类型，每种类别组件的职能都是不同的。

**基础组件**

主要是指可复用，实现某类功能，且不包含任何业务的组件。例如一个 `button` 或者一个 `list` 组件，仅仅比 HTML 标签高一个层级的组件，我们称为基础组件，对于现在的开发来说，我们一般会使用 `antd、element` 或者是自研的 UI 组件库，所以基础组件一般不需要我们自己设计。

**容器组件**

例如页面上的各种布局组件，仅仅是作为一个容器而存在的组件，不会涉及到太复杂的逻辑，而是将多个业务组件有序排列起来的组件，我们称之为容器组件。

**展示组件**

展示组件就像它的名字一样，只用来展示，只负责拿到数据、渲染数据，不存在第三方的依赖，它可以有状态，但它的状态只存活在自己的生命周期里。

**通用组件**

通用组件也好理解，就是一个组件到处可用，复用性强，包含通用的组件逻辑，也可以存在三方依赖。

**业务组件**

业务组件最大的特点就是基于业务，大部分业务组件都是一次性组件，当然也有可复用的业务组件，但是复用次数并不多，它基于最小业务抽离，业务组件中往往是由一些基础组件、复用组件、展示型组件再加上一些业务逻辑以及特有的UI合成。

**高阶组件**

高阶组件，即 HOC，可以看作是函数式编程的组合，简单理解就是一个函数接收一个组件作为参数，返回一个增强型的组件。



### 颗粒度（组件划分）

关于组件的颗粒度，其实很多同学都是为了设计而设计，把组件关系、包括层级搞得很复杂，其实每一个组件都有其独特的划分目的，有的是为了复用实现，有的是为了封装复杂度清晰业务实现，这也是我们之前说组件设计前要先分类的原因，先明确职责再做其他。

看过设计模式的同学应该有了解过很多设计原则，其中一个就是单一职责原则，这个原则放在开发组件中也同样适用。在原则上一个组件就只负责一件事，这就是单一原则所带来的好处也非常明显，就是可以更大可能的复用组件。但如果职责过于单一，也会造成组件碎片化严重，过于抽象。

组件划分的依据通常是业务逻辑、功能，要考虑各组件之间的关系是否明确，及可复用度。组件颗粒度的划分要根据实际情况权衡，太小会提高维护成本，太大又不够灵活、复用性不够。

往往我们会看到很多人说，一个页面的 HTML 要尽量的少，逻辑清晰，然后很多同学会把一个组件拆成很多个小组件，造成了组件碎片化极其严重。还有把一个组件划分成几个组件，把这些组件划分成多个小组件，再把这些小组件分成多个更小的组件，一个组件甚至嵌套了四五个层级，造成了组件树的深度问题。这两种方式下来每个组件看着是代码挺少挺舒服，但是亲们考虑维护吗？这真的有必要吗？

组件的单一职责原则是建立在可复用的基础上的。如果它只是几行代码，那么最终可能会创建更多的代码来分离它，这是没有必要的。如果当前组件的逻辑不太会出现在其他地方，那么将它嵌入其中更好，如果需要，你可以随时抽离，而对于组件树的深度（层级问题）最好不要超过三级。

当然，如果你的组件中存在频繁的状态更改，并且当前在一个较大的、关系较紧密的组件里，为了避免性能受到影响最好抽离出来更小的组件按需引入使用。



### 可读性（设计规范）

组件的职能以及组件粒度都确定好了，那下一步就是规范这一块了，也就是我们常说的代码可读性。

组件名称、参数名称、事件名称一定要设计的通俗易懂，最好能做到代码即注释这种程度，并且所有的组件都应用于一套命名规则。

所有的组件一定要有详细的文档、注释和变更历史，这样才能查到来龙去脉，比如新版本组件加了什么功能是因为什么等等。



### 通用性（可扩展）

组件的分类、颗粒度划分、规范都确定好之后，在编写组件之前，我们还应该考虑组件的通用性，它也是根据组件的类型来设计的，像一些业务组件，极低的复用可能性，我们就不需要考虑，但是像一些通用组件，我们就不得不考虑这个问题了。

组件最开始的设计是为了当时的页面设计进行封装的，那之后的包括其他项目的页面设计极大可能是与之前不同的，那和之前设计的组件就有点不一样了，组件也就不能用了。一旦发生这样的情况，就说明我们之前所设计的组件是不能用的，就需要重新设计了。

所以设计之初我们就应该考虑好这一点，如果是一个通用型的组件，我们就要提前控制一下，尽量减少组件内部对 DOM 的操作，暴露给开发者进行操作，而组件本身侧重底层逻辑和基本的 DOM 结构就可以了。对外尽可能的多的暴露一些可扩展的操作，做到能够满足大多数类似需求。



### 扁平化参数（数据清晰）

为了数据传递比较清晰，组件的参数应该像 HTML 原生元素那样，只接受原始类型（字符串、数值、布尔值和函数）作为属性，避免复杂的对象，当然，数据除外。

像 Vue 这样的框架，如果我们将所有参数作为一个对象传递进组件，看着倒是挺简单，但由于 `state` 和 `props` 频繁被 `watch` 和 `update` 就会存在大量的重复渲染，造成性能问题，而扁平化的参数除了可以让组件数据变得清晰，也可以规避这一点。



### 松耦合（合理依赖）

组件中经常存在一个组件依赖多个子组件这种关系，对于合理的依赖，我的理解很简单，我们只需要做到父组件依赖的是自组件的功能，而不是逻辑，只要我们可以做到删除子组件，父组件只是丢失了一个小功能，而不是造成功能异常，那就成功了一半。

遵循单项数据流的原则，就像开发中多个子组件依赖于父组件的某个数据，假如子组件可以修改父组件数据的话，一个子组件变化会引发所有依赖这个数据的子组件发生变化，这显然是不对的。所以，父组件可以控制子组件，子组件一定不能影响父组件。



### 可靠性（组件稳定）

最后就是组件的可靠性了，组件的核心特性之一就是复用，一般抽离出来的组件都是要复用的，所以一定要把极端场景要考虑到，使用时不能因为传错了一个参数就整个组件就挂了，包括组件的缺省值（即默认值）等等都属于可靠性的范畴。

那怎样让一个组件变得可靠，很简单：单元测试。不经历单元测试，你永远不知道组件会有什么莫名其妙的BUG。



## 写在最后

平常聊到组件化时，我们总觉得它是一个很大的概念，包含非常多的知识，但是又无从说起。因为它是一种思想，一般只要认为是思想的东西，都比较飘渺，往往都是知道做又不知道怎么说，这很正常。

这篇文章是比较务虚的，都是概念性的东西，但我们总归要先理解概念在进行实践。技术在不断更新，各种新技术层出不穷，不论是通过 JS 来分割组件还是使用 Web components 标准亦或是其他手段，始终不变的是组件化设计思想。当然，后面也会通过设计一个 UI组件库为例进行实践，敬请期待，点个关注不迷路。

以上就是我个人对组件化的理解了，不是太全面，欢迎补充，如果有理解不对的地方，也欢迎指正！码字不易，欢迎点赞！