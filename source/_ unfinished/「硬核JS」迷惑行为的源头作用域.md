# 「硬核JS」你不知道的作用域

## 要知道

对于前端小伙伴来说，作用域是一个很基础的话题，其实大部分的人都是被填鸭式的灌输作用域的概念，并没有好好理解 `JS独特的作用域` ，可以说，很多刚入门包括一些基础不硬的同学都知道作用域，却并不了解作用域，所以，今天我们来好好说一下它

写此文前我反复看了几遍 `你不知道的JavaScript` 上卷作用域章节，算是一个总结，真的推荐稍微有些基础但是不太强硬的同学看一看这套别名叫小黄书的书，和红宝书不同，反复读不只是因为它的内容好，还因为我觉得这本书读起来不仅不会枯燥无味，反而会越看越有意思

推荐大家多看几遍，正常来讲每看一遍都会有不同感悟，多来几遍直到你再次看这本书时觉得索然无味、学不到东西了，就吃透了，这本书写作手法也很值得学习，致敬小黄书，所以本文叫 `你不知道的作用域` 😄 

小黄书还是需要有点基础的人看会好些，此文我会在语义上再进行简化，通过书中知识总结再结合个人理解给大家叙述出来，这样更通俗易懂，皆大欢喜，当然有不对的地方请指教



## 了解编译

### 代码是怎样运行的？

我们所写的代码是其实是由 `CPU` 执行的，而 `CPU` 并不能直接执行如 `if…else` 之类的语句，它只能执行二进制指令，但是二进制指令对人类实在是太不友好了，我们很难快速准确的判断一个二进制指令例如 `1000010010101001` 代表什么

你能想象的到我们写程序如果只写 0 和 1 是一种怎样的体验吗，所以后来有了 `汇编语言` ， `汇编语言` 实际上就是二进制指令的助记符，但它并没有改变这种操作方式，它只是二进制指令的映射，再后来就有了各种高级语言，所谓高级语言，JS就是一门高级语言，那么什么是高级语言，可以这样说

高级语言之所以称之为 `高级`，就是因为它更加符合我们的思维和阅读习惯，就比如 `if…else` 这种语句看起来要比 `1010101010` 舒服的多了



### 什么是编译？

上面我们说到高级语言，但计算机并不能直接执行高级语言，所以还需要把高级语言转化为 `汇编语言/机器指令` 才能执行，而这个过程就是编译

其实我们现在说的编译，也是所有编译语言在代码执行前都会经历的阶段，它由三个步骤组成

- 分词/词法分析
- 解析/语法分析
- 代码生成



#### 分词/词法分析

分词/词法分析 (Tokenizing/Lexing)，这个过程其实就是将字符串分割为有意义的 **代码块**，这些代码块称之为**词法单元**

例如变量的声明

```js
var a = 1
```

这行代码会被分为以下词法单元 `var`、`a`、`=`、`1` ，这之中空格算或不算词法单元取决于空格对于这门编程语言是否具有意义

而后这些零散的词法单元会组成一个词法单元流（可以说是一个数组）进行解析



#### 解析/语法分析

解析/语法分析（Parsing），这个过程会把词法单元流（就是那个词法单元组成的数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，也就是常说的 **AST抽象语法树 (Abstract Syntax Tree, AST)** ，碍于章节 AST 抽象语法树这里暂不细说，有时间单独介绍



#### 代码生成

将 AST 转化为可执行的代码



### JavaScript中的编译

JS 引擎中的编译器做的事情与上述说的编译过程类似，不过因为 JS 的编译是在代码执行前，所以 JS 编译执行效率就比一般静态语言敏感得多，so，也复杂了许多

 JS 引擎在这部分也做了很多优化

- 对语法分析和代码生成阶段进行优化（例如针对冗余元素进行优化），目的是提高编译后的执行效率
- 对编译过程进行优化（如 JIT，延迟编译或者重编译），目的是缩短编译过程，保证性能最佳



## 编译器、引擎和作用域

要彻底的搞清楚JS的作用域，首先，我们要了解 JS 中 ` 引擎、编译器、作用域` 之间的关系，其实很好理解

我们写一段 JS 代码，是由 `JS 引擎` 来负责统筹解析和执行的，类似于一个国王的位置，国王会自己干活吗，肯定不会，国王都只负责指挥，有一群大臣们帮他干活

那么 `JS 引擎` 要想知道我们写的是什么意思并执行，就会用到 `编译器` 这个大臣 ，`JS引擎` 会告诉它的大臣：编译器啊，你给我分析一下这段代码吧

`编译器` 负责编译也就是分析代码，然后再进行代码生成，这个最后生成的代码，生成的并不是我们所理解的代码，而是机器能够读懂的指令代码，这个过程中还需要其他大臣的配合， `作用域` 就是其中一个

`作用域` 负责的是收集并维护所有声明的标识符 ( 变量 ) 组成的一系列查询，并且实施一套严格的规则，用来确定当前执行的代码对这些标识符的访问权限

```js
var a = 1
```

还是以这行代码为例

首先，编译器再编译时，遇到 `var a` ，会先问作用域在当前作用域下有没有 `a` 这样一个名字的变量存在

如果没有，编译器会要求作用域在当前作用域下的集合中声明一个名字为 `a` 的变量

如果有，则会直接忽略声明继续进行后面的编译

接着，编译器会生成运行时所需要的代码交给引擎，引擎开始运行代码

引擎运行代码时，会先问作用域，在当前作用域下有没有一个叫 `a` 的变量

如果有，会直接使用变量 `a`，并把它赋值为2

如果没有，引擎会往上层作用域查找（作用域是嵌套关系，详细请看下文作用域嵌套），找到还是赋值，最终如果还是没有找到，就会抛出一个异常





## 作用域

上面我们说过，`作用域` 负责的是收集并维护所有声明的标识符 ( 变量 ) 组成的一系列查询，并且实施一套严格的规则，用来确定当前执行的代码对这些标识符的访问权限



### LHS & RHS

**LHS：**当变量出现在赋值操作的左侧，试图查找到变量的容器本身，从而可以对其赋值，即找到赋值操作的目标，我们先简单的称它为左查询

```js
a = 1

// 这里是LHS引用，因为我们不关心当前变量a的值，只想给 =1 这个操作找一个目标
```



**RHS：**可以简单理解为当变量出现在赋值操作右侧，其查找目标为取到目标的源值，即找到这个变量的具体值而非容器，我们先简单的称它为右查询

```js
console.log(a)

// 这里是RHS引用，因为变量a没有任何赋值操作，我们只需要找到a的值传递给.log()
```



我们来看一个例子，看看都经历了那些查询

```js
function fn(a){
  console.log(a)
}
fn(1)
```

首先最后一行的 `fn(1)` 函数调用，需要对函数 `fn` 进行一次 RHS 引用

接着执行函数，`fn` 函数有一个形参 `a` ，那么当函数执行实参1被传进函数时，会有一个隐式的赋值操作 `a = 1` ，所以这里有一步 LHS 引用

最后的 `console.log(a)` 又是一次 RHS 引用

可能你会觉得函数 `fn` 在声明时也是一个 LHS ，但是并不是如此，编译器可以在代码生成的同时处理声明和值的定义，但是如上面这个例子，引擎在执行代码时，并不会有线程专门用来将一个函数值分配给 `fn` 

那么上例的执行过程就比较清晰了

小黄书中对这段代码中引擎和作用域之间的操作用一段有意思的对话表达了出来

> ***引擎***：嘿 *作用域*，我要对 `fn` 进行 RHS 引用，听说过它吗？
>
> ***作用域***：听说过，*编译器* 刚在一秒钟之前声明了它，它是一个函数，给你
>
> ***引擎***：好的，我要执行 `fn` 了
>
> ***引擎***：嘿，*作用域*，我得到了一个 `a` 的 LHS 引用，听说过它吗？
>
> ***作用域***：啊，是的，听说过，*编译器* 刚才将它声明为 `foo` 的一个正式参数了，给你
>
> ***引擎***：*作用域*，再次感谢你。现在，该把 `1` 赋值给 `a` 了
>
> ***引擎***：嘿，*作用域*，又一次打扰你，我需要 RHS 查询 `console`，听说过它吗？
>
> ***作用域***：是的，我得到 `console` 了，它是一个内置对象，给你
>
> ***引擎***：完美，我看看这里面是不是有一个 `log(..)`，它是一个函数，太好了
>
> ***引擎***：嘿，*作用域*，帮我查一下 `a` 的 RHS 引用呗？我想我记得它，但是想再次确认一下
>
> ***作用域***：你是对的，*引擎*。同一个家伙，没变，给你
>
> ***引擎***：真棒，传递 `a` 的值，也就是 `1`，给 `log(..)` 

看到这里，你可能会疑问，有必要区分LHS和RHS吗？

答案是当然有必要

其一，你在和别人讲的时候，很自然的在话语中掺杂上左右查询，别人不知道即可装B。。

其二，变量在没有声明的时候，这两种查询的行为是不同的，如下面的例子

```js
function fn(a){
  console.log(a+b)
  b = a
}
fn(1)
```

这个例子中，`console.log(a+b)` 中在对变量 `b` 进行 RHS 查询时，`b` 未声明，则会抛出一个 `ReferenceError` 异常

而在 LHS 查询中遇到这种未声明的变量时，则会在全局作用域即 `window` 下创建一个具有该名称的变量，并返回给引擎，当然要严格模式下除外，严格模式下 LHS 也会和 RHS 一样抛出一个 `ReferenceError` 异常

在 RHS 查询中如果查到了一个变量，但是你要尝试给这个值进行不合理的操作，比如对一个非函数类型的值进行函数调用，或者引用 `null` 或 `undefined` 类型的值中的属性，引擎会给你抛出一个 `TypeError` 的类型异常

总的来说，LHS 和 RHS 查询都会在当前执行作用域中开始，没有找到的话会向上级作用域逐级查找，最终抵达顶层的全局作用域，这个时候无论找到没找到都会停止，没有找到的话按照上述步骤操作，这个逐级查找的过程，也是接下来要说的作用域的嵌套关系



### 作用域嵌套

作用域有 `块级作用域`，还有 `函数作用域`，当一个块或函数作用域嵌套在另一个块或者函数作用域时，就有了作用域的嵌套，因此，当前作用域无法找到某个变量时，引擎会逐步向上级作用域查找，知道找到或者抵达最外层的全局作用域为止

例如

```js
var a = 1
function fn(){
  console.log(a)
  console.log(b)
}
fn()
```

如上所示，在调用函数 `fn` 时

> ***引擎：***fn作用域的兄弟们，见过 a 吗，我需要对它进行 RHS 引用？
>
> ***fn作用域：***没听说过，一边去
>
> ***引擎：***fn的上级作用域兄弟，哦，原来是全局作用域大哥，你见过 a 吗？
>
> ***全局作用域：***在呢在呢，给你
>
> ***引擎：***好嘞，多谢全局大哥
>
> ***引擎：***fn作用域的兄弟们，见过 b 吗，我需要对它进行 RHS 引用？
>
> ***fn作用域：***没听说过，一边去
>
> ***引擎：***fn的上级作用域兄弟，全局作用域大哥，你见过 b 吗？
>
> ***全局作用域：***没得没得
>
> ***引擎：***那没办法了，RHS查询没查到，抛出一个 ReferenceError 异常吧



### 函数作用域



### 块作用域



### 词法作用域



### 欺骗词法





