# 「前端工程四部曲」模块化演进（下）

## 写在前面





## CSS模块化

对于JS模块化，很多人都不陌生，但说起CSS模块化，可能大家就没有这么清晰了。其实大部分人都会重点关注JS而忽略CSS，但CSS也是前端三剑客不可或缺的一部分，在编写CSS的时候，绝大多数人都是比较随意的，所以就会经常造成一些开发痛点。那接下来我们就来聊一聊CSS模块化。



### 为什么需要CSS模块化？

其实平常我们使用 Vue、React这类框架时，就已经使用到了CSS模块化。回顾一下历史，从我们手写原生CSS，到后面使用Sass/Less等预处理器，再到使用 PostCSS 等后处理器，或者是使用CSS Module以及CSS in JS，都是对标某些问题而产生的比较针对性的方案。

而CSS模块化所针对的问题追溯源头其实都很简单：

- Class命名重复
- Class层级结构
- CSS代码复用
- CSS文件拆分

这也是为什么存在CSS模块化的原因。



### CSS模块化方案演进

#### BEM

BEM 是一种非常有用、强大且简单的命名约定，可以说是一个CSS命名规范，也可以说是一种思想。它使前端代码更易于阅读和理解、更易于使用、更易于扩展、更健壮和明确，并且更加严格。

BEM的意思就是块（block）、元素（element）、修饰符（modifier）,是由Yandex团队提出的一种前端命名方法论。这种巧妙的命名方法让你的CSS类对其他开发者来说更加透明而且更有意义。BEM命名约定更加严格，而且包含更多的信息，它们用于一个团队开发一个耗时的大项目。

我们可以简单看一下这个命名约定：

```css
.block{} /* 代表了更高级别的抽象或组件 */
.block__element{} /*  代表.block的后代，用于形成一个完整的.block的整体 */
.block--modifier{} /* 代表.block的不同状态或不同版本 */
```

上面的描述有些官方，其实 `.block` 就代表一个视图中的一个块，而 `.block__element` 代表的是 `.block` 块下的元素 ，最后的 `.block--modifier` 代表的是 `.block` 块的修饰符。当然也可以按照下面这种写：

```css
.site-search{} /* 块 */
.site-search__field{} /* 元素 */
.site-search--full{} /* 修饰符 */
```

唯一的区别是多了一个 `-` 符号，这个是为了让你自己的视图块可以用单个连字符来界定，`__` 代表元素，`--` 代表修饰符。

举个例子：

常规CSS命名写法如下：

```html
<form class="site-search  full">
  <input type="text" class="field">
  <input type="Submit" value ="Search" class="button">
</form>   
```

BEM命名写法如下：

```html
<form class="site-search  site-search--full">
  <input type="text" class="site-search__field">
  <input type="Submit" value ="Search" class="site-search__button">
</form>  
```

如上，常规的CSS写法乍一看简单漂亮，但代码量大的时候，就会很乱，不知道 class 对应的是什么。而 BEM 就不一样了，虽然看上去很丑，但我们能清晰地看到有个叫 `.site-search` 的块，它内部是 `.site-search__field` 和 `site-search__button` 两个元素。并且 `.site-search` 还有另外一种形态叫 `.site-search--full`。

**优点：**

BEM 的优点在于所产生的 CSS 类名都只使用一个类别选择器，可以避免传统做法中由于多个类别选择器嵌套带来的复杂的属性级联问题。BEM 命名规则中，所有的 CSS 样式规则都只用一个类别选择器。因此所有样式规则的特异性（specificity）都是相同的，也就不存在复杂的优先级问题。这可以简化属性值的层叠规则。代码清单中的命名规则的好处在于每个 CSS 类名都很简单明了，而且类名的层次关系可以与 DOM 节点的树型结构相对应。

**缺点：**

CSS 类名会比较长而且复杂，根据 BEM 命名规则产生的 CSS 类名都会很复杂，粗暴来说就是丑。不过熟悉了命名规则之后，可以很容易理解其含义。和 BEM 的实用性比起来，丑一点根本不值一提！！



#### OOCSS

`Object Oriented CSS`，面向对象的CSS，旨在编写高可复用、低耦合和高扩展的CSS代码。

`OOCSS`是以面向对象的思想去定义样式，将抽象和实现分离，抽离公共代码。

`OOCSS` 认为 container（容器） 和 content（内容） 是需要隔离开的。也就是说，尽量不要去使用依赖于节点结构位置的样式定义。比如这样的就是不允许的：

```css
.container-list .title{ /* ... */ }
```

`OOCSS` 建议：

```css
.title{ /* ... */ }
```

举个例子大家就理解了，假如我们有一个容器如下：

```html
<div class="container"></div>

<style>
  .container{
    width: 50%;
    background: yellow;
    border: 1px solid #ccc;
    margin: 10px 15px 20px 25px;
  }
</style>
```

按照 `OOCSS` ，会为这个容器创建更多的类，并且每个样式对应一个类，这样是为了后面可以重复使用这些组件的样式，避免重复写相同的样式。如下：

```html
<div class="sizelof2 solidGray bgYellow mt10 ml25 mr15 mb20"></div>

<style>
  .sizelof2{width: 50%};
  .solidGray{border: 1px solid #ccc};
  .bgYellow {background: yellow};
  .mt10 {margin-top: 10px};
	.mr15 {margin-right: 15px};
	.mb20 {margin-bottom: 20px};
	.ml25 {margin-left: 25px};
</style>
```

如上，是不是很好理解？

**优点：**

- CSS 代码减少，降低工作量。
- 样式重复利用，代码简洁，便于维护。
- 代码少，加载速度快。
- 能轻松构造新的页面布局，或制作新的页面风格。

**缺点：**

- 适用于大型网站项目（重复组件，样式多），小型项目优势不明显（代码少）。
- 需巧妙运用，因为特定要求（强调重复使用类选择器，避免使用ID选择器）如果运用不得当，反而可能会造成后续维护困难，所以使用此方案最好写上说明文档。



#### AMCSS

AMCSS 即 `Attribute Modules for CSS` 。
AM是一种使用 HTML 属性及其值而非样式元素的类的技术。这样每个属性都可以有效地声明一个单独的命名空间来封装样式信息，从而使HTML和CSS更具可读性和可维护性。

简单来说就是通过 CSS 属性选择器来模块化CSS。

举个例子，如下这段代码：

```html
<div class="button button-large button-blue">Button</div>

<style>
	.button {/* ... */}
  .button-large {/* ... */}
  .button-blue {/* ... */}
</style>
```

转变成 AMCSS，由于是基于属性控制，就变成了下面这样：

```html
<div button="large blue">Button</div>

<style>
	[button] {/* ... */}
  [button~="large"] {/* ... */}
  [button~="blue"] {/* ... */}
</style>
```

为了避免属性冲突，我们一般会为其加一个统一的前缀，如 `am-` ，所以最终就变成下面这样子：

```html
<div am-button="large blue">Button</div>

<style>
	[am-button] {/* ... */}
  [am-button~="large"] {/* ... */}
  [am-button~="blue"] {/* ... */}
</style>
```

不要觉得奇怪，这只是对 CSS 选择器的灵活运用而已，不了解的话可以 Google 一下 CSS 属性选择器。

**优点：**

属性值得灵活性，相当于通过属性值来增加命名空间，减少全局名称空间，以便更好的将 CSS 模块化。

**缺点：**

属性选择器的性能和类名相比差别很大，过度使用可能会产生可感知的性能问题。主要还是要看使用场景。



#### SMACSS



#### ACSS

ACSS，全称是 `Atomic CSS` ，即原子化的 CSS。

用最简单的话来说就是，把每一个单一的作用定义一个Class，确保整个样式表没有一条重复的样式，这样复用性是最高的，代码也最少，但是每个元素就需要一堆的 Class。

如下这种：

```html
<div class="mt-10 w-100 h-15"></div>
// mt-10 > margin-top: 10px;
// w-100 > width: 100px;
// h-15 > height: 15px;
```

直接写原子化的 CSS 还是比较累的，不过好在有现成框架，像 [Tailwind CSS](https://tailwindcss.com/) 就是一个基于 ACSS 的可定制的基础层 CSS 框架，使用人数还挺多，它提供了构建定制化所需的构建块，无需重新覆盖内建于框架内中的风格。

也就是说有人定义好了一套原子化的 CSS 类样式，我们只需要下载并引入这个 CSS 包就可使用了。

使用 Tailwind CSS 后的代码就像下面这样，每个块元素上通过很多的 CSS 类来定义样式，基本不需要我们自己定义，即使有，也只需要写很少一部分额外的 CSS 代码，当然，也可以对 Tailwind 做一些扩展，使用方面不细说，看文档即可：

```html
<div class="flex align-center justify-center p-4">
  <div class="box-border h-32 w-32 p-4 border-4 border-gray-400 bg-gray-200">
  </div>
</div>
```

可以看到，CSS 代码最小化了，而 HTML 膨胀了，虽然不用考虑命名，但是要记一堆新规则。市场对它的评价褒贬都有吧！





## 参考

[BEM](http://getbem.com/) 

[AMCSS](http://amcss.github.io/)

[BEM —— 源自Yandex的CSS 命名方法论](https://segmentfault.com/a/1190000000391762)

[浅谈CSS模块化](https://www.cnblogs.com/zhuanzhuanfe/p/7449931.html)
